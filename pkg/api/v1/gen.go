// Package v1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package v1

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
)

// contextKey provides a type for use with context.WithValue.
type contextKey string

const (
	BasicScopes  contextKey = "Basic.Scopes"
	BearerScopes contextKey = "Bearer.Scopes"
	HeaderScopes contextKey = "Header.Scopes"
)

// Defines values for UserGroupPerm.
const (
	UserGroupPermAdmin UserGroupPerm = "admin"
	UserGroupPermOwner UserGroupPerm = "owner"
	UserGroupPermUser  UserGroupPerm = "user"
)

// Defines values for SortOrderParam.
const (
	SortOrderParamAsc  SortOrderParam = "asc"
	SortOrderParamDesc SortOrderParam = "desc"
)

// Defines values for ListGroupsParamsOrder.
const (
	ListGroupsParamsOrderAsc  ListGroupsParamsOrder = "asc"
	ListGroupsParamsOrderDesc ListGroupsParamsOrder = "desc"
)

// Defines values for ListGroupUsersParamsOrder.
const (
	ListGroupUsersParamsOrderAsc  ListGroupUsersParamsOrder = "asc"
	ListGroupUsersParamsOrderDesc ListGroupUsersParamsOrder = "desc"
)

// Defines values for ListUsersParamsOrder.
const (
	ListUsersParamsOrderAsc  ListUsersParamsOrder = "asc"
	ListUsersParamsOrderDesc ListUsersParamsOrder = "desc"
)

// Defines values for ListUserGroupsParamsOrder.
const (
	Asc  ListUserGroupsParamsOrder = "asc"
	Desc ListUserGroupsParamsOrder = "desc"
)

// AuthToken defines model for AuthToken.
type AuthToken struct {
	ExpiresAt *time.Time `json:"expires_at,omitempty"`
	Token     *string    `json:"token,omitempty"`
}

// AuthVerify defines model for AuthVerify.
type AuthVerify struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Username  *string    `json:"username,omitempty"`
}

// Group Model to represent group
type Group struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	ID        *string    `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`
	Slug      *string    `json:"slug,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// Notification Generic response for errors and validations
type Notification struct {
	Errors  *[]Validation `json:"errors,omitempty"`
	Message *string       `json:"message,omitempty"`
	Status  *int          `json:"status,omitempty"`
}

// Profile Model to represent profile
type Profile struct {
	Active    *bool        `json:"active,omitempty"`
	Admin     *bool        `json:"admin,omitempty"`
	Auths     *[]UserAuth  `json:"auths,omitempty"`
	CreatedAt *time.Time   `json:"created_at,omitempty"`
	Email     *string      `json:"email,omitempty"`
	Fullname  *string      `json:"fullname,omitempty"`
	Groups    *[]UserGroup `json:"groups,omitempty"`
	ID        *string      `json:"id,omitempty"`
	Password  *string      `json:"password,omitempty"`
	Profile   *string      `json:"profile,omitempty"`
	UpdatedAt *time.Time   `json:"updated_at,omitempty"`
	Username  *string      `json:"username,omitempty"`
}

// Provider Model to represent auth provider
type Provider struct {
	Display *string `json:"display,omitempty"`
	Driver  *string `json:"driver,omitempty"`
	Icon    *string `json:"icon,omitempty"`
	Name    *string `json:"name,omitempty"`
}

// User Model to represent user
type User struct {
	Active    *bool       `json:"active,omitempty"`
	Admin     *bool       `json:"admin,omitempty"`
	Auths     *[]UserAuth `json:"auths,omitempty"`
	CreatedAt *time.Time  `json:"created_at,omitempty"`
	Email     *string     `json:"email,omitempty"`
	Fullname  *string     `json:"fullname,omitempty"`
	ID        *string     `json:"id,omitempty"`
	Password  *string     `json:"password,omitempty"`
	Profile   *string     `json:"profile,omitempty"`
	UpdatedAt *time.Time  `json:"updated_at,omitempty"`
	Username  *string     `json:"username,omitempty"`
}

// UserAuth Model to represent user auth
type UserAuth struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Provider  *string    `json:"provider,omitempty"`
	Ref       *string    `json:"ref,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// UserGroup Model to represent user group
type UserGroup struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Group Model to represent group
	Group     *Group         `json:"group,omitempty"`
	GroupID   string         `json:"group_id"`
	Perm      *UserGroupPerm `json:"perm,omitempty"`
	UpdatedAt *time.Time     `json:"updated_at,omitempty"`

	// User Model to represent user
	User   *User  `json:"user,omitempty"`
	UserID string `json:"user_id"`
}

// UserGroupPerm defines model for UserGroup.Perm.
type UserGroupPerm string

// Validation General structure to show validation errors
type Validation struct {
	Field   *string `json:"field,omitempty"`
	Message *string `json:"message,omitempty"`
}

// AuthCodeParam defines model for AuthCodeParam.
type AuthCodeParam = string

// AuthProviderParam defines model for AuthProviderParam.
type AuthProviderParam = string

// AuthStateParam defines model for AuthStateParam.
type AuthStateParam = string

// GroupID defines model for GroupParam.
type GroupID = string

// PagingLimitParam defines model for PagingLimitParam.
type PagingLimitParam = int

// PagingOffsetParam defines model for PagingOffsetParam.
type PagingOffsetParam = int

// SearchQueryParam defines model for SearchQueryParam.
type SearchQueryParam = string

// SortColumnParam defines model for SortColumnParam.
type SortColumnParam = string

// SortOrderParam defines model for SortOrderParam.
type SortOrderParam string

// UserID defines model for UserParam.
type UserID = string

// ActionFailedError Generic response for errors and validations
type ActionFailedError = Notification

// AlreadyAttachedError Generic response for errors and validations
type AlreadyAttachedError = Notification

// BadCredentialsError Generic response for errors and validations
type BadCredentialsError = Notification

// BadRequestError Generic response for errors and validations
type BadRequestError = Notification

// GroupResponse Model to represent group
type GroupResponse = Group

// GroupUsersResponse defines model for GroupUsersResponse.
type GroupUsersResponse struct {
	// Group Model to represent group
	Group  *Group      `json:"group,omitempty"`
	Limit  int64       `json:"limit"`
	Offset int64       `json:"offset"`
	Total  int64       `json:"total"`
	Users  []UserGroup `json:"users"`
}

// GroupsResponse defines model for GroupsResponse.
type GroupsResponse struct {
	Groups []Group `json:"groups"`
	Limit  int64   `json:"limit"`
	Offset int64   `json:"offset"`
	Total  int64   `json:"total"`
}

// InternalServerError Generic response for errors and validations
type InternalServerError = Notification

// InvalidTokenError Generic response for errors and validations
type InvalidTokenError = Notification

// LoginResponse defines model for LoginResponse.
type LoginResponse = AuthToken

// NotAttachedError Generic response for errors and validations
type NotAttachedError = Notification

// NotAuthorizedError Generic response for errors and validations
type NotAuthorizedError = Notification

// NotFoundError Generic response for errors and validations
type NotFoundError = Notification

// ProfileResponse Model to represent profile
type ProfileResponse = Profile

// ProvidersResponse defines model for ProvidersResponse.
type ProvidersResponse struct {
	Providers []Provider `json:"providers"`
	Total     int64      `json:"total"`
}

// RefreshResponse defines model for RefreshResponse.
type RefreshResponse = AuthToken

// SuccessMessage Generic response for errors and validations
type SuccessMessage = Notification

// TokenResponse defines model for TokenResponse.
type TokenResponse = AuthToken

// UserGroupsResponse defines model for UserGroupsResponse.
type UserGroupsResponse struct {
	Groups []UserGroup `json:"groups"`
	Limit  int64       `json:"limit"`
	Offset int64       `json:"offset"`
	Total  int64       `json:"total"`

	// User Model to represent user
	User *User `json:"user,omitempty"`
}

// UserResponse Model to represent user
type UserResponse = User

// UsersResponse defines model for UsersResponse.
type UsersResponse struct {
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
	Total  int64  `json:"total"`
	Users  []User `json:"users"`
}

// ValidationError Generic response for errors and validations
type ValidationError = Notification

// VerifyResponse defines model for VerifyResponse.
type VerifyResponse = AuthVerify

// CreateGroupBody defines model for CreateGroupBody.
type CreateGroupBody struct {
	Name *string `json:"name,omitempty"`
	Slug *string `json:"slug,omitempty"`
}

// CreateUserBody defines model for CreateUserBody.
type CreateUserBody struct {
	Active   *bool   `json:"active,omitempty"`
	Admin    *bool   `json:"admin,omitempty"`
	Email    *string `json:"email,omitempty"`
	Fullname *string `json:"fullname,omitempty"`
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// GroupUserDropBody defines model for GroupUserDropBody.
type GroupUserDropBody struct {
	User string `json:"user"`
}

// GroupUserPermBody defines model for GroupUserPermBody.
type GroupUserPermBody struct {
	Perm string `json:"perm"`
	User string `json:"user"`
}

// LoginAuthBody defines model for LoginAuthBody.
type LoginAuthBody struct {
	Password string `json:"password"`
	Username string `json:"username"`
}

// RedirectAuthBody defines model for RedirectAuthBody.
type RedirectAuthBody struct {
	Token string `json:"token"`
}

// UpdateGroupBody defines model for UpdateGroupBody.
type UpdateGroupBody struct {
	Name *string `json:"name,omitempty"`
	Slug *string `json:"slug,omitempty"`
}

// UpdateProfileBody defines model for UpdateProfileBody.
type UpdateProfileBody struct {
	Email    *string `json:"email,omitempty"`
	Fullname *string `json:"fullname,omitempty"`
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// UpdateUserBody defines model for UpdateUserBody.
type UpdateUserBody struct {
	Active   *bool   `json:"active,omitempty"`
	Admin    *bool   `json:"admin,omitempty"`
	Email    *string `json:"email,omitempty"`
	Fullname *string `json:"fullname,omitempty"`
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// UserGroupDropBody defines model for UserGroupDropBody.
type UserGroupDropBody struct {
	Group string `json:"group"`
}

// UserGroupPermBody defines model for UserGroupPermBody.
type UserGroupPermBody struct {
	Group string `json:"group"`
	Perm  string `json:"perm"`
}

// LoginAuthJSONBody defines parameters for LoginAuth.
type LoginAuthJSONBody struct {
	Password string `json:"password"`
	Username string `json:"username"`
}

// RedirectAuthJSONBody defines parameters for RedirectAuth.
type RedirectAuthJSONBody struct {
	Token string `json:"token"`
}

// CallbackProviderParams defines parameters for CallbackProvider.
type CallbackProviderParams struct {
	// State Auth state
	State *AuthStateParam `form:"state,omitempty" json:"state,omitempty"`

	// Code Auth code
	Code *AuthCodeParam `form:"code,omitempty" json:"code,omitempty"`
}

// ListGroupsParams defines parameters for ListGroups.
type ListGroupsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListGroupsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListGroupsParamsOrder defines parameters for ListGroups.
type ListGroupsParamsOrder string

// CreateGroupJSONBody defines parameters for CreateGroup.
type CreateGroupJSONBody struct {
	Name *string `json:"name,omitempty"`
	Slug *string `json:"slug,omitempty"`
}

// UpdateGroupJSONBody defines parameters for UpdateGroup.
type UpdateGroupJSONBody struct {
	Name *string `json:"name,omitempty"`
	Slug *string `json:"slug,omitempty"`
}

// DeleteGroupFromUserJSONBody defines parameters for DeleteGroupFromUser.
type DeleteGroupFromUserJSONBody struct {
	User string `json:"user"`
}

// ListGroupUsersParams defines parameters for ListGroupUsers.
type ListGroupUsersParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListGroupUsersParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListGroupUsersParamsOrder defines parameters for ListGroupUsers.
type ListGroupUsersParamsOrder string

// AttachGroupToUserJSONBody defines parameters for AttachGroupToUser.
type AttachGroupToUserJSONBody struct {
	Perm string `json:"perm"`
	User string `json:"user"`
}

// PermitGroupUserJSONBody defines parameters for PermitGroupUser.
type PermitGroupUserJSONBody struct {
	Perm string `json:"perm"`
	User string `json:"user"`
}

// UpdateProfileJSONBody defines parameters for UpdateProfile.
type UpdateProfileJSONBody struct {
	Email    *string `json:"email,omitempty"`
	Fullname *string `json:"fullname,omitempty"`
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// ListUsersParams defines parameters for ListUsers.
type ListUsersParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListUsersParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListUsersParamsOrder defines parameters for ListUsers.
type ListUsersParamsOrder string

// CreateUserJSONBody defines parameters for CreateUser.
type CreateUserJSONBody struct {
	Active   *bool   `json:"active,omitempty"`
	Admin    *bool   `json:"admin,omitempty"`
	Email    *string `json:"email,omitempty"`
	Fullname *string `json:"fullname,omitempty"`
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// UpdateUserJSONBody defines parameters for UpdateUser.
type UpdateUserJSONBody struct {
	Active   *bool   `json:"active,omitempty"`
	Admin    *bool   `json:"admin,omitempty"`
	Email    *string `json:"email,omitempty"`
	Fullname *string `json:"fullname,omitempty"`
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// DeleteUserFromGroupJSONBody defines parameters for DeleteUserFromGroup.
type DeleteUserFromGroupJSONBody struct {
	Group string `json:"group"`
}

// ListUserGroupsParams defines parameters for ListUserGroups.
type ListUserGroupsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListUserGroupsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListUserGroupsParamsOrder defines parameters for ListUserGroups.
type ListUserGroupsParamsOrder string

// AttachUserToGroupJSONBody defines parameters for AttachUserToGroup.
type AttachUserToGroupJSONBody struct {
	Group string `json:"group"`
	Perm  string `json:"perm"`
}

// PermitUserGroupJSONBody defines parameters for PermitUserGroup.
type PermitUserGroupJSONBody struct {
	Group string `json:"group"`
	Perm  string `json:"perm"`
}

// LoginAuthJSONRequestBody defines body for LoginAuth for application/json ContentType.
type LoginAuthJSONRequestBody LoginAuthJSONBody

// RedirectAuthJSONRequestBody defines body for RedirectAuth for application/json ContentType.
type RedirectAuthJSONRequestBody RedirectAuthJSONBody

// CreateGroupJSONRequestBody defines body for CreateGroup for application/json ContentType.
type CreateGroupJSONRequestBody CreateGroupJSONBody

// UpdateGroupJSONRequestBody defines body for UpdateGroup for application/json ContentType.
type UpdateGroupJSONRequestBody UpdateGroupJSONBody

// DeleteGroupFromUserJSONRequestBody defines body for DeleteGroupFromUser for application/json ContentType.
type DeleteGroupFromUserJSONRequestBody DeleteGroupFromUserJSONBody

// AttachGroupToUserJSONRequestBody defines body for AttachGroupToUser for application/json ContentType.
type AttachGroupToUserJSONRequestBody AttachGroupToUserJSONBody

// PermitGroupUserJSONRequestBody defines body for PermitGroupUser for application/json ContentType.
type PermitGroupUserJSONRequestBody PermitGroupUserJSONBody

// UpdateProfileJSONRequestBody defines body for UpdateProfile for application/json ContentType.
type UpdateProfileJSONRequestBody UpdateProfileJSONBody

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody CreateUserJSONBody

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody UpdateUserJSONBody

// DeleteUserFromGroupJSONRequestBody defines body for DeleteUserFromGroup for application/json ContentType.
type DeleteUserFromGroupJSONRequestBody DeleteUserFromGroupJSONBody

// AttachUserToGroupJSONRequestBody defines body for AttachUserToGroup for application/json ContentType.
type AttachUserToGroupJSONRequestBody AttachUserToGroupJSONBody

// PermitUserGroupJSONRequestBody defines body for PermitUserGroup for application/json ContentType.
type PermitUserGroupJSONRequestBody PermitUserGroupJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Authenticate an user by credentials
	// (POST /auth/login)
	LoginAuth(w http.ResponseWriter, r *http.Request)
	// Fetch the available auth providers
	// (GET /auth/providers)
	ListProviders(w http.ResponseWriter, r *http.Request)
	// Retrieve real token after redirect
	// (POST /auth/redirect)
	RedirectAuth(w http.ResponseWriter, r *http.Request)
	// Refresh an auth token before it expires
	// (GET /auth/refresh)
	RefreshAuth(w http.ResponseWriter, r *http.Request)
	// Verify validity for an authentication token
	// (GET /auth/verify)
	VerifyAuth(w http.ResponseWriter, r *http.Request)
	// Callback to parse the defined provider
	// (GET /auth/{provider}/callback)
	CallbackProvider(w http.ResponseWriter, r *http.Request, provider AuthProviderParam, params CallbackProviderParams)
	// Request the redirect to defined provider
	// (GET /auth/{provider}/request)
	RequestProvider(w http.ResponseWriter, r *http.Request, provider AuthProviderParam)
	// Fetch all available groups
	// (GET /groups)
	ListGroups(w http.ResponseWriter, r *http.Request, params ListGroupsParams)
	// Create a new group
	// (POST /groups)
	CreateGroup(w http.ResponseWriter, r *http.Request)
	// Delete a specific group
	// (DELETE /groups/{group_id})
	DeleteGroup(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Fetch a specific group
	// (GET /groups/{group_id})
	ShowGroup(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Update a specific group
	// (PUT /groups/{group_id})
	UpdateGroup(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Unlink a user from group
	// (DELETE /groups/{group_id}/users)
	DeleteGroupFromUser(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Fetch all users attached to group
	// (GET /groups/{group_id}/users)
	ListGroupUsers(w http.ResponseWriter, r *http.Request, groupID GroupID, params ListGroupUsersParams)
	// Attach a user to group
	// (POST /groups/{group_id}/users)
	AttachGroupToUser(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Update user perms for group
	// (PUT /groups/{group_id}/users)
	PermitGroupUser(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Fetch profile details of the personal account
	// (GET /profile/self)
	ShowProfile(w http.ResponseWriter, r *http.Request)
	// Update your own profile information
	// (PUT /profile/self)
	UpdateProfile(w http.ResponseWriter, r *http.Request)
	// Retrieve an unlimited auth token
	// (GET /profile/token)
	TokenProfile(w http.ResponseWriter, r *http.Request)
	// Fetch all available users
	// (GET /users)
	ListUsers(w http.ResponseWriter, r *http.Request, params ListUsersParams)
	// Create a new user
	// (POST /users)
	CreateUser(w http.ResponseWriter, r *http.Request)
	// Delete a specific user
	// (DELETE /users/{user_id})
	DeleteUser(w http.ResponseWriter, r *http.Request, userID UserID)
	// Fetch a specific user
	// (GET /users/{user_id})
	ShowUser(w http.ResponseWriter, r *http.Request, userID UserID)
	// Update a specific user
	// (PUT /users/{user_id})
	UpdateUser(w http.ResponseWriter, r *http.Request, userID UserID)
	// Unlink a group from user
	// (DELETE /users/{user_id}/groups)
	DeleteUserFromGroup(w http.ResponseWriter, r *http.Request, userID UserID)
	// Fetch all groups attached to user
	// (GET /users/{user_id}/groups)
	ListUserGroups(w http.ResponseWriter, r *http.Request, userID UserID, params ListUserGroupsParams)
	// Attach a group to user
	// (POST /users/{user_id}/groups)
	AttachUserToGroup(w http.ResponseWriter, r *http.Request, userID UserID)
	// Update group perms for user
	// (PUT /users/{user_id}/groups)
	PermitUserGroup(w http.ResponseWriter, r *http.Request, userID UserID)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Authenticate an user by credentials
// (POST /auth/login)
func (_ Unimplemented) LoginAuth(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch the available auth providers
// (GET /auth/providers)
func (_ Unimplemented) ListProviders(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Retrieve real token after redirect
// (POST /auth/redirect)
func (_ Unimplemented) RedirectAuth(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Refresh an auth token before it expires
// (GET /auth/refresh)
func (_ Unimplemented) RefreshAuth(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Verify validity for an authentication token
// (GET /auth/verify)
func (_ Unimplemented) VerifyAuth(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Callback to parse the defined provider
// (GET /auth/{provider}/callback)
func (_ Unimplemented) CallbackProvider(w http.ResponseWriter, r *http.Request, provider AuthProviderParam, params CallbackProviderParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Request the redirect to defined provider
// (GET /auth/{provider}/request)
func (_ Unimplemented) RequestProvider(w http.ResponseWriter, r *http.Request, provider AuthProviderParam) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all available groups
// (GET /groups)
func (_ Unimplemented) ListGroups(w http.ResponseWriter, r *http.Request, params ListGroupsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new group
// (POST /groups)
func (_ Unimplemented) CreateGroup(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a specific group
// (DELETE /groups/{group_id})
func (_ Unimplemented) DeleteGroup(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch a specific group
// (GET /groups/{group_id})
func (_ Unimplemented) ShowGroup(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a specific group
// (PUT /groups/{group_id})
func (_ Unimplemented) UpdateGroup(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a user from group
// (DELETE /groups/{group_id}/users)
func (_ Unimplemented) DeleteGroupFromUser(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all users attached to group
// (GET /groups/{group_id}/users)
func (_ Unimplemented) ListGroupUsers(w http.ResponseWriter, r *http.Request, groupID GroupID, params ListGroupUsersParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a user to group
// (POST /groups/{group_id}/users)
func (_ Unimplemented) AttachGroupToUser(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update user perms for group
// (PUT /groups/{group_id}/users)
func (_ Unimplemented) PermitGroupUser(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch profile details of the personal account
// (GET /profile/self)
func (_ Unimplemented) ShowProfile(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update your own profile information
// (PUT /profile/self)
func (_ Unimplemented) UpdateProfile(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Retrieve an unlimited auth token
// (GET /profile/token)
func (_ Unimplemented) TokenProfile(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all available users
// (GET /users)
func (_ Unimplemented) ListUsers(w http.ResponseWriter, r *http.Request, params ListUsersParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new user
// (POST /users)
func (_ Unimplemented) CreateUser(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a specific user
// (DELETE /users/{user_id})
func (_ Unimplemented) DeleteUser(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch a specific user
// (GET /users/{user_id})
func (_ Unimplemented) ShowUser(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a specific user
// (PUT /users/{user_id})
func (_ Unimplemented) UpdateUser(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a group from user
// (DELETE /users/{user_id}/groups)
func (_ Unimplemented) DeleteUserFromGroup(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all groups attached to user
// (GET /users/{user_id}/groups)
func (_ Unimplemented) ListUserGroups(w http.ResponseWriter, r *http.Request, userID UserID, params ListUserGroupsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a group to user
// (POST /users/{user_id}/groups)
func (_ Unimplemented) AttachUserToGroup(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update group perms for user
// (PUT /users/{user_id}/groups)
func (_ Unimplemented) PermitUserGroup(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// LoginAuth operation middleware
func (siw *ServerInterfaceWrapper) LoginAuth(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LoginAuth(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListProviders operation middleware
func (siw *ServerInterfaceWrapper) ListProviders(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListProviders(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// RedirectAuth operation middleware
func (siw *ServerInterfaceWrapper) RedirectAuth(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RedirectAuth(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// RefreshAuth operation middleware
func (siw *ServerInterfaceWrapper) RefreshAuth(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RefreshAuth(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// VerifyAuth operation middleware
func (siw *ServerInterfaceWrapper) VerifyAuth(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.VerifyAuth(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CallbackProvider operation middleware
func (siw *ServerInterfaceWrapper) CallbackProvider(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "provider" -------------
	var provider AuthProviderParam

	err = runtime.BindStyledParameterWithOptions("simple", "provider", chi.URLParam(r, "provider"), &provider, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "provider", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params CallbackProviderParams

	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", true, false, "state", r.URL.Query(), &params.State)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "state", Err: err})
		return
	}

	// ------------- Optional query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, false, "code", r.URL.Query(), &params.Code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CallbackProvider(w, r, provider, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// RequestProvider operation middleware
func (siw *ServerInterfaceWrapper) RequestProvider(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "provider" -------------
	var provider AuthProviderParam

	err = runtime.BindStyledParameterWithOptions("simple", "provider", chi.URLParam(r, "provider"), &provider, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "provider", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RequestProvider(w, r, provider)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListGroups operation middleware
func (siw *ServerInterfaceWrapper) ListGroups(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListGroupsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListGroups(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateGroup operation middleware
func (siw *ServerInterfaceWrapper) CreateGroup(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateGroup(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteGroup operation middleware
func (siw *ServerInterfaceWrapper) DeleteGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteGroup(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ShowGroup operation middleware
func (siw *ServerInterfaceWrapper) ShowGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ShowGroup(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateGroup operation middleware
func (siw *ServerInterfaceWrapper) UpdateGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateGroup(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteGroupFromUser operation middleware
func (siw *ServerInterfaceWrapper) DeleteGroupFromUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteGroupFromUser(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListGroupUsers operation middleware
func (siw *ServerInterfaceWrapper) ListGroupUsers(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListGroupUsersParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListGroupUsers(w, r, groupID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachGroupToUser operation middleware
func (siw *ServerInterfaceWrapper) AttachGroupToUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachGroupToUser(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// PermitGroupUser operation middleware
func (siw *ServerInterfaceWrapper) PermitGroupUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PermitGroupUser(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ShowProfile operation middleware
func (siw *ServerInterfaceWrapper) ShowProfile(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ShowProfile(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateProfile operation middleware
func (siw *ServerInterfaceWrapper) UpdateProfile(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateProfile(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// TokenProfile operation middleware
func (siw *ServerInterfaceWrapper) TokenProfile(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TokenProfile(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListUsers operation middleware
func (siw *ServerInterfaceWrapper) ListUsers(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUsersParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUsers(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateUser operation middleware
func (siw *ServerInterfaceWrapper) CreateUser(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateUser(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteUser operation middleware
func (siw *ServerInterfaceWrapper) DeleteUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteUser(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ShowUser operation middleware
func (siw *ServerInterfaceWrapper) ShowUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ShowUser(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateUser operation middleware
func (siw *ServerInterfaceWrapper) UpdateUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateUser(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteUserFromGroup operation middleware
func (siw *ServerInterfaceWrapper) DeleteUserFromGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteUserFromGroup(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListUserGroups operation middleware
func (siw *ServerInterfaceWrapper) ListUserGroups(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUserGroupsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUserGroups(w, r, userID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachUserToGroup operation middleware
func (siw *ServerInterfaceWrapper) AttachUserToGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachUserToGroup(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// PermitUserGroup operation middleware
func (siw *ServerInterfaceWrapper) PermitUserGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PermitUserGroup(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/login", wrapper.LoginAuth)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/providers", wrapper.ListProviders)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/redirect", wrapper.RedirectAuth)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/refresh", wrapper.RefreshAuth)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/verify", wrapper.VerifyAuth)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/{provider}/callback", wrapper.CallbackProvider)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/{provider}/request", wrapper.RequestProvider)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/groups", wrapper.ListGroups)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/groups", wrapper.CreateGroup)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/groups/{group_id}", wrapper.DeleteGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/groups/{group_id}", wrapper.ShowGroup)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/groups/{group_id}", wrapper.UpdateGroup)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/groups/{group_id}/users", wrapper.DeleteGroupFromUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/groups/{group_id}/users", wrapper.ListGroupUsers)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/groups/{group_id}/users", wrapper.AttachGroupToUser)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/groups/{group_id}/users", wrapper.PermitGroupUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/profile/self", wrapper.ShowProfile)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/profile/self", wrapper.UpdateProfile)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/profile/token", wrapper.TokenProfile)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/users", wrapper.ListUsers)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/users", wrapper.CreateUser)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/users/{user_id}", wrapper.DeleteUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/users/{user_id}", wrapper.ShowUser)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/users/{user_id}", wrapper.UpdateUser)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/users/{user_id}/groups", wrapper.DeleteUserFromGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/users/{user_id}/groups", wrapper.ListUserGroups)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/users/{user_id}/groups", wrapper.AttachUserToGroup)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/users/{user_id}/groups", wrapper.PermitUserGroup)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
